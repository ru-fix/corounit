package ru.fix.corounit.allure


data class Row1<out A>(val a: A)

data class Row2<out A, out B>(val a: A, val b: B)

data class Row3<out A, out B, out C>(val a: A, val b: B, val c: C)

data class Row4<out A, out B, out C, out D>(val a: A, val b: B, val c: C, val d: D)

data class Row5<out A, out B, out C, out D, out E>(val a: A, val b: B, val c: C, val d: D, val e: E)

data class Row6<out A, out B, out C, out D, out E, out F>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F)

data class Row7<out A, out B, out C, out D, out E, out F, out G>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G)

data class Row8<out A, out B, out C, out D, out E, out F, out G, out H>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H)

data class Row9<out A, out B, out C, out D, out E, out F, out G, out H, out I>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I)

data class Row10<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J)

data class Row11<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K)

data class Row12<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L)

data class Row13<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M)

data class Row14<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N)

data class Row15<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O)

data class Row16<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P)

data class Row17<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P, out Q>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P, val q: Q)

data class Row18<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P, out Q, out R>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P, val q: Q, val r: R)

data class Row19<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P, out Q, out R, out S>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P, val q: Q, val r: R, val s: S)

data class Row20<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P, out Q, out R, out S, out T>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P, val q: Q, val r: R, val s: S, val t: T)

data class Row21<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P, out Q, out R, out S, out T, out U>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P, val q: Q, val r: R, val s: S, val t: T, val u: U)

data class Row22<out A, out B, out C, out D, out E, out F, out G, out H, out I, out J, out K, out L, out M, out N, out O, out P, out Q, out R, out S, out T, out U, out V>(val a: A, val b: B, val c: C, val d: D, val e: E, val f: F, val g: G, val h: H, val i: I, val j: J, val k: K, val l: L, val m: M, val n: N, val o: O, val p: P, val q: Q, val r: R, val s: S, val t: T, val u: U, val v: V)

fun <A> row(a: A) = Row1(a)
fun <A, B> row(a: A, b: B) = Row2(a, b)
fun <A, B, C> row(a: A, b: B, c: C) = Row3(a, b, c)
fun <A, B, C, D> row(a: A, b: B, c: C, d: D) = Row4(a, b, c, d)
fun <A, B, C, D, E> row(a: A, b: B, c: C, d: D, e: E) = Row5(a, b, c, d, e)
fun <A, B, C, D, E, F> row(a: A, b: B, c: C, d: D, e: E, f: F) = Row6(a, b, c, d, e, f)
fun <A, B, C, D, E, F, G> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G) = Row7(a, b, c, d, e, f, g)
fun <A, B, C, D, E, F, G, H> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) = Row8(a, b, c, d, e, f, g, h)
fun <A, B, C, D, E, F, G, H, I> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) = Row9(a, b, c, d, e, f, g, h, i)
fun <A, B, C, D, E, F, G, H, I, J> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) = Row10(a, b, c, d, e, f, g, h, i, j)
fun <A, B, C, D, E, F, G, H, I, J, K> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) = Row11(a, b, c, d, e, f, g, h, i, j, k)
fun <A, B, C, D, E, F, G, H, I, J, K, L> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L) = Row12(a, b, c, d, e, f, g, h, i, j, k, l)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M) = Row13(a, b, c, d, e, f, g, h, i, j, k, l, m)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N) = Row14(a, b, c, d, e, f, g, h, i, j, k, l, m, n)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O) = Row15(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P) = Row16(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q) = Row17(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R) = Row18(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S) = Row19(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T) = Row20(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T, u: U) = Row21(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> row(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T, u: U, v: V) = Row22(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)



suspend fun <A> parameterized(vararg rows: Row1<A>, test: suspend (A) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a})") {
            test.invoke(row.a)
        }
    }
}


suspend fun <A, B> parameterized(vararg rows: Row2<A, B>, test: suspend (A, B) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b})") {
            test.invoke(row.a, row.b)
        }
    }
}


suspend fun <A, B, C> parameterized(vararg rows: Row3<A, B, C>, test: suspend (A, B, C) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c})") {
            test.invoke(row.a, row.b, row.c)
        }
    }
}


suspend fun <A, B, C, D> parameterized(vararg rows: Row4<A, B, C, D>, test: suspend (A, B, C, D) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d})") {
            test.invoke(row.a, row.b, row.c, row.d)
        }
    }
}


suspend fun <A, B, C, D, E> parameterized(vararg rows: Row5<A, B, C, D, E>, test: suspend (A, B, C, D, E) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e)
        }
    }
}


suspend fun <A, B, C, D, E, F> parameterized(vararg rows: Row6<A, B, C, D, E, F>, test: suspend (A, B, C, D, E, F) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f)
        }
    }
}


suspend fun <A, B, C, D, E, F, G> parameterized(vararg rows: Row7<A, B, C, D, E, F, G>, test: suspend (A, B, C, D, E, F, G) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H> parameterized(vararg rows: Row8<A, B, C, D, E, F, G, H>, test: suspend (A, B, C, D, E, F, G, H) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I> parameterized(vararg rows: Row9<A, B, C, D, E, F, G, H, I>, test: suspend (A, B, C, D, E, F, G, H, I) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J> parameterized(vararg rows: Row10<A, B, C, D, E, F, G, H, I, J>, test: suspend (A, B, C, D, E, F, G, H, I, J) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K> parameterized(vararg rows: Row11<A, B, C, D, E, F, G, H, I, J, K>, test: suspend (A, B, C, D, E, F, G, H, I, J, K) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L> parameterized(vararg rows: Row12<A, B, C, D, E, F, G, H, I, J, K, L>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M> parameterized(vararg rows: Row13<A, B, C, D, E, F, G, H, I, J, K, L, M>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N> parameterized(vararg rows: Row14<A, B, C, D, E, F, G, H, I, J, K, L, M, N>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> parameterized(vararg rows: Row15<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> parameterized(vararg rows: Row16<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> parameterized(vararg rows: Row17<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p}, ${row.q})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p, row.q)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R> parameterized(vararg rows: Row18<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p}, ${row.q}, ${row.r})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p, row.q, row.r)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S> parameterized(vararg rows: Row19<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p}, ${row.q}, ${row.r}, ${row.s})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p, row.q, row.r, row.s)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T> parameterized(vararg rows: Row20<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p}, ${row.q}, ${row.r}, ${row.s}, ${row.t})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p, row.q, row.r, row.s, row.t)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U> parameterized(vararg rows: Row21<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p}, ${row.q}, ${row.r}, ${row.s}, ${row.t}, ${row.u})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p, row.q, row.r, row.s, row.t, row.u)
        }
    }
}


suspend fun <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V> parameterized(vararg rows: Row22<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V>, test: suspend (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V) -> Unit) {
    val parentStep = AllureStep.fromCurrentCoroutineContext()
    for (row in rows) {
        parentStep.step("parameterized(${row.a}, ${row.b}, ${row.c}, ${row.d}, ${row.e}, ${row.f}, ${row.g}, ${row.h}, ${row.i}, ${row.j}, ${row.k}, ${row.l}, ${row.m}, ${row.n}, ${row.o}, ${row.p}, ${row.q}, ${row.r}, ${row.s}, ${row.t}, ${row.u}, ${row.v})") {
            test.invoke(row.a, row.b, row.c, row.d, row.e, row.f, row.g, row.h, row.i, row.j, row.k, row.l, row.m, row.n, row.o, row.p, row.q, row.r, row.s, row.t, row.u, row.v)
        }
    }
}

